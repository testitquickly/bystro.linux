Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2024-10-26T19:40:30+03:00

====== Симлинки и хардлинки ======

[ @теория @symlink @hardlink @inode ]

===== Теория =====

В природе не существует книг. Любая книга состоит из отдельных букв, которые соединяются в знакомые или незнакомые слова, которые расположены на отдельных листах, которые стоят один за другим в каком-то порядке и состоят из отдельных глав, которые соединяются логикой общего рассказа…

А ещё в природе не существует городов, нет улиц и нет нумерованных домов на этих улицах. Это нам, людям, удобно воспринимать какие-то постоянные поселения как города, в которых есть жители, которые постоянно живут в домах, которые организованы в улицы, у которых есть названия…

==== Что такое файл? ====

Вот и с точки зрения операционной системы файлов не существует — на диске есть сектора, и в каждом секторе или пусто, или есть набор нулей и единиц. Нам удобно воспринимать такие наборы как единые сущности, как мы это делаем с книгами.

На HDD (шкаф для книг) есть секторы (страницы). Содержимое секторов — ''0'' и ''1'' (буквы). Какие-то наборы данных (слова из букв) помещаются в один сектор на HDD, другие занимают несколько секторов. Для человека удобнее воспринимать эти наборы данных как собранные воедино в файлы (книги).

На HDD все листы этой «книги» могут находиться вместе, под одной обложкой, а могут лежать на разных полках, и даже в разных шкафах, и даже на разных этажах соседних зданий, да ещё в разных комнатах. Логически (и юридически) они всё ещё представляют собой цельную книгу, которую можно читать, но технически неудобно бегать по этажам от страницы к странице. Разумнее приказать кому-то (компьютеру) собрать все эти разрозненные данные с разных мест HDD и показать нам всё в виде единой книги.

Любой файл/каталог (каталоги тоже файлы, но особого формата) — это набор каких-то данных — нулей и единиц, которые записаны на одном или нескольких секторах на диске, последовательно — рядом, или в разных местах.

Каждый сектор или объявлен свободным для записи (даже если на нём есть какая-то упорядоченная информация), или принадлежащим к какой-то группе секторов.

Когда сектор на диске (один или множество) группируется, в системе делается объявление о том, что «к определенной группе отныне относится вот этот сектор (и этот, и этот, и вот этот…)». 

К каждой “группе секторов” прилагается техническое описание, которое называется «Индексный Дескриптор», в оригинале Index Descriptor, оно же — //''inode''.// Это технический набор метаданных файла, это только //техническая// информация о файле, без его имени и содержимого:

* Тип объекта (файл, каталог, символическая ссылка и т.д.)
* Права доступа (чтение, запись, выполнение)
* ID владельца и группы
* Размер файла
* Временные метки (создание, последняя модификация, последний доступ)
* Кол-во ссылок на файл
* Адреса блоков данных, где фактически хранится содержимое файла на диске

То есть, в inode записано всё, кроме  (1) имени и (2) содержимого файла, потому что содержимое файла — нули и единицы, которые уже записаны в секторах диска, последовательно или вразнобой. А имя файла — отдельная абстракция в системе.

Операционная система «знает» про файлы на диске через эти самые //inode// (Индексный Дескриптор, набор метаданных)//.//

Когда файл создают, операционная система связывает имя файла/каталога с уникальным inode. Точнее, само имя хранится в каталоге, а inode указывает на физические блоки, в которых находится содержимое файла. Это позволяет системе отличать //содержимое// файла от его //имени//.

Увидеть inode файла:

''ls -i /home/astenix/test.txt''

Пример ответа:

''7734848 /home/astenix/test.txt''

Циферки — это тот самый inode, указатель места (точнее, области) на диске.

Можно прочитать содержимое этого файла и так

'''
cat /home/astenix/test.txt
'''

и вот так

'''
cat "$(find /home/astenix -inum 7734848)"
'''

Посмотреть, что записано в inode для этого файла:

1) вкратце

''ls -li /home/astenix/test.txt''

Пример ответа:

''7734848 -rw-r--r-- 1 astenix astenix 42 ноя 12 09:03 /home/astenix/test.txt''

2) подробно

''stat /home/astenix/test.txt''

Пример ответа:

  ''File: /home/astenix/test.txt''
''Size: 42              Blocks: 8          IO Block: 4096   regular file''
''Device: 803h/2051d      Inode: 7734848     Links: 1''
''Access: (0644/-rw-r--r--)  Uid: (1000/astenix)   Gid: (1000/astenix)''
''Access: 2025-11-12 09:03:20.000000000 +0200''
''Modify: 2025-11-12 09:03:00.000000000 +0200''
''Change: 2025-11-12 09:03:00.000000000 +0200''
''Birth: 2025-11-12 08:59:47.000000000 +0200''

Тут смотрим на 

''Device: 803h/2051d      Inode: 7734848     Links: 1''

Device: 803h / 2051d — это номер устройства, на котором хранится файл:

* 803h — шестнадцатеричное представление (hex).
* 2051d — десятичное (dec).

Это значение — внутренний идентификатор блочного устройства (партиции на диске), на котором находится файл, например /dev/sda1. Он кодирует major и minor номера устройства, которые можно посмотреть отдельно:

''stat -c "major=%t minor=%T" /home/astenix/test.txt''

Пример ответа:

''major=2 minor=1''

что означает /dev/sda1 (2 — это SCSI-диск, 1 — первый раздел на этом HDD).

Собственно, на вопрос «Что такое файл?» единственно корректным ответом будет «//Файл — это ссылка на inode//» (область на диске).

=== P.S. ===

А ещё у операционной системы есть //''Dentriy''// (directory entry) – директория, она же каталог (folder). Это тоже файл, но специфичный — он или «пустой», или к нему «приписаны» другие файлы и каталоги, которые могут находится последовательно на нескольких секторах, а могут быть разбросаны по всему диску.… То есть, каталоги — это тоже файлы. И каждый inode в каждом каталоге должен быть уникальным.

Одна из теоретических проблем, которую можно разглядеть на досуге — inode могут «закончиться», и нельзя будет создать новый файл или каталог на устройстве, даже если там достаточно свободного места. При этом уже имеющиеся файлы можно полноценно изменять. На практике хз, бывает ли, вероятно да, если на диске мало места, а на нём очень интенсивно создают/удаляют новые файлы.

А ещё бывает, что имя файла удалили, но файл в системе ещё открыт, например, его «держит» процесс с ''PID 1234'', а это значит, что ядро Linux всё ещё «знает» inode удалённого файла. Проверить процесс:

'''
ls -l /proc/1234/fd/
'''

Увидим что-то вроде

''lrwx------ 1 user user 64 ноя 12 09:12 3 -> /home/astenix/test.txt (deleted)''

Вот это “''3 ->''” нам и нужно. Можно прочитать содержимое файла напрямую:

''cat /proc/1234/fd/3''

==== //hardlink// ====

Итак, на диске есть набор информации (нули и единицы в секторах диска), которые мы воспринимаем как единый файл (книгу). Чтобы не видет файлы в виде номеров (inode), в системе можно сделать на каждый inode ссылку в виде букв и чисел, вроде ''abc_1.txt''. Для нас это «имя файла». Для компьютера это  //hardlink// — «жёсткая ссылка» на inode файла. 

То есть, имя каждого файла на диске — это хардлинк на inode файла. А значит имя файла — это всегда ссылка на определённый inode («//Файл — это ссылка на inode//»). У каждого файла/каталога всегда только один inode на диске. 

Дальше мелкая магия — можно сделать несколько хардлинков на один и тот же inode. Для человека это выглядит как «Есть несколько файлов, у которых одно и то же содержимое». Для системы это несколько разных названий у одной и той же книги.

Зачем это нужно? 

В многопользовательских системах это даёт возможность обращаться к одному и тому же файлу из разных каталогов и из разных userspace под разными именами. Предположим, что на сервере в общем доступе находится файл «dailyReports.txt» Я могу в своём /home сделать хардлинк на этот файл и назову его «Отчёт.txt»; другой пользователь на том же компьютере в своём /home назовёт этот же файл (точнее, ссылку к нему) — «Анекдоты.txt», третий назовёт тот же файл «Важные данные.doc»… Файл один и тот же, а названия у него разные. И каждый пользователь, который будет редактировать как будто бы разные файлы, а на деле — один и тот же.

Для пользователя хардлинк на файл — это сам файл, который можно читать, редактировать, перемещать и удалять.

Можно в одном каталоге сделать два хардлинка на один и тот же файл из другого каталога. Незачем, но можно даже сделать хардлинк на файл в том же каталоге, что и оригинал…

Если все-таки сделать несколько хардлинков на один и тот же файл, что в системе этот файл будет существовать до тех пор, пока сохраняется хотя бы один хардлинк на него. Даже если оригинальный файл будет переименован или перенесён в другой каталог или удалён — нули и единицы на диске останутся на месте, и другие хардлинки на этот файл всё так же будут открывать его содержимое. Помним о том, что удаление файла с HDD ничего не удаляет, просто сектора, которые до сих пор занимало содержимое этого файла, объявляются открытыми для записи. 

В [[Software:Midnight Commander]] после редактирования оригинального файла при сохранении появляется вопрос — «Файл имеет жёсткие ссылки. Отсоединить перед сохранением?». Если сказать да — изменения в файле не будут отображаться при открытии файла через хардлинк. А хардлинк вроде бы откроет тот же файл на редактирование, но изменения в нём не будут отображаться (нет ссылки — нет изменений). На самом деле хардлинк начинает указывать на новый inode, и будет сохранять все изменения в новом файле. Вполне резонно, что может возникнуть путаница с тем, кто кто-то клянётся, что записал в файл что-то новое, а кто-то открывает этот же файл, но изменений не видит. Оба одновременно правы…

Важное условие: нельзя сделать хардлинк на каталог. Хардлинки — это всегда только имена файлов.

См. [[+hardlink]]

==== //symlink// ====

Symbolic link, он же сокращённо «symlink» — это ссылка на //хардлинк//. Не прямо на //inode// файла, а на его имя.

То есть, при обращении к симлинку происходит обращение к хардлинку, который сообщает, к какому именно inode надо обратиться. 

Можно сделать сразу несколько симлинков на один и тот же файл — каждая «ссылка на файл» указывает на один и тот же хардлинк, который указывает на один и тот же inode.

В отличие от хардлинков, которые «ссылаются» только на файлы, симлинки можно делать и на файлы, и на каталоги.

Симлинки, как и хардлинки, тоже можно свободно переносить в разные каталоги — оригинал останется на месте.

Внешне симлинк тоже не распознать — файл и файл, но в [[Software:Midnight Commander]] они нарочно отображаются с дополнительными символами:
* у симлинка на файл первый символ в имени — “''@''” (собачка).
* у симлинка на каталога первый символ в имени — “''~''“ (тильда).

Основная разница между симлинком и хардлинком в том, что происходит с оригинальным inode при удалении хардлинка и симлинка. Если хардлинки делает один пользователь, и хардлинк тоже один, то при удалении хардлинка оригинальный файл тоже будет удалён (inode будет помечен как свободный). А при удалении симлинков с оригиналом файла ничего не происходит:

* при чтении/редактировании симлинка открывается на чтение/редактирование оригинал,
* при переименовании или удалении симлинка оригинал остаётся на месте — однозначно и безопасно,
* при переименовании или удалении оригинального файла симлинк остаётся, но выглядит как файл, который «невозможно открыть», ведь имени, на которое было указание, больше нет. В MC в этом случае первый символ в названии симлинка превращается в восклицательный знак — удобная подсказка.

И если снова создать на месте старого файла новый файл, то симлинк снова заработает.

И да, симлинки тоже можно именовать и переименовывать как угодно — оригинальный файл/каталог это не затрагивает.

См. [[+symlink]]

==== //alias// ====

Это симлинк или на файл/каталог, или на команду в консоли. Может быть временным, пока не закроется консоль, или постоянным.

См. [[+alias]]

===== Примеры =====

В Linux можно запускать любой скрипт в консоли из любого каталога как обычную команду, если сделать на нужный скрипт симлинк в каталоге с бинарниками.

==== Debian update ====

Например, я собрал последовательнось команд для обновления Debian и положил его в файл „''/home/mySettings/myScripts/debian/debian_update_and_upgrade.sh''”. 

	Сделал скрипт.

В консоли можно запустить этот скрипт так:

''/home/mySettings/myScripts/debian/debian_update_and_upgrade.sh''

Или сперва зайти в каталог с файлом

''cd /home/mySettings/myScripts/debian/''

и уже оттуда его запустить:

''./debian_update_and_upgrade.sh'' 

А ещё можно сделать символическую ссылку на этот файл, положить её в какой-то каталог «внутри профиля пользователя» (''/~/.local/bin/'' если надо сделать симлинк только для своего юзера или ''/usr/local/bin/'' чтобы симлинк был доступен всем юзерам в системе) и вызывать её в консоли как консольную команду. 

Или можно сделать такой симлинк доступным для всех пользователей на компьютере (разумно, когда общий сервер).

У симлинка может быть любое имя, отличное от оригинального файла, и иногда это приносит дополнительное удобство. Например, оригинал будет называться „debian_update_and_upgrade.sh”, а симлинк можно называть очень сокращенно, например, „''debup''” — расширение для файла в этом случае вообще не имеет значения.

	Или „''updeb''”.
	Или „''dp''”.
	Или „''updatemazafaka''”.
	Или все сразу.

==== Cсылки на программное обеспечение ====

Например, пишем программу, которая обращается к исполняемым файлам Java. Где они находятся?

В консоли при вызове

''java''

происходит пробег по нескольким каталогам и файлам — да, симлинк может ссылаться на другой симлинк, который ссылается на третий симлинк…

1. Читаем ''/usr/bin/java'' — это не просто файл без расширения, это симлинк на ''/etc/alternatives/java''
2. Читаем ''/etc/alternatives/java'' — это симлинк на ''/usr/lib/jvm/java-17-openjdk-amd64/bin/java''
3. Читаем ''/usr/lib/jvm/java-17-openjdk-amd64/bin/java'' — это симлинк на ''/usr/lib64/ld-linux-x86-64.so.2''
4. Читаем ''/usr/lib64/ld-linux-x86-64.so.2'' — это симлинк на ''/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2'' с набором дополнительных инструкций
5. Читаем, если не надоело, файл ''/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2''…

Версии java постоянно меняются, меняется и содержимое файлов, и их расположение. Но через систему симлинков на стороне пользователя вызов ''java'' всегда происходит через одну и ту же команду. А вызов 

''java --version''

с ответом вроде

''openjdk 17.0.13 2024-10-15''
''OpenJDK Runtime Environment (build 17.0.13+11-Debian-2deb12u1)''
''OpenJDK 64-Bit Server VM (build 17.0.13+11-Debian-2deb12u1, mixed mode, sharing)''

это же чтение содержимого переменных из разных файлов, в том числе и из ''/usr/lib/jvm/java-17-openjdk-amd64/release'':

''IMPLEMENTOR="Debian"''
''JAVA_RUNTIME_VERSION="17.0.13+11-Debian-2deb12u1"''
''JAVA_VERSION="17.0.13"''
''JAVA_VERSION_DATE="2024-10-15"''
''…''

При выпуске следующей версии — ''java-18'' — исполняемые файлы уже будут находиться в каталоге с другим названием, и информацию о версии придется читать из другого файла в каталоге с другим названием — ''/usr/lib/jvm/java-18-openjdk-amd64/release'' Однако благодаря системе перекрёстных хард и симлинков команда обращения будет прежняя.

Третий пример характерен для древних времён, когда на дисках всегда было ОЧЕНЬ мало места. Есть набор файлов, которые находятся в разных каталогах. И надо собрать их них условный плэйлист (сделаем прямую аналогию с аудиофайлами). Можно скопировать все нужные нам файлы в один новый каталог, но это значит, что на диске станет меньше свободного места. А можно в этот новый каталог положить только симлинки на нужные файлы, которые лежат в разных каталогах — если таких файлов много, то получится однозначная экономия места на hdd.

==== linkfolder ====

Мелкий лайфхак — можно зайти в какой-то каталог и не выходя из него сделать в каталоге своего профиля симлинк на каталог, в котором находишься:

''ln -s "$(realpath .)" ~/"$(basename "$PWD")"''

Почему ''realpath'' — потому, что иногда находишься в каталоге, который уже является симлинком. Надо ссылаться на оригинал.

Есть смысл сделать для этого дела алиас в ~/.bashrc

''alias linkfolder='ln -s "$(realpath .)" ~/"$(basename "$PWD")"'''

и выполнять это чудодействие одной командой:

''linkfolder''

===== Узнать файл по inode =====

Предположим, что я знаю inode, и надо понять, какой файл на него указывает. 

==== Знаю каталог ====

Для этого хорошо бы знать, в каком каталоге находится файл:

''stat "$(find /home/astenix/test -xdev -inum 32506352 -print -quit 2>/dev/null)"''

Здесь:

''-xdev'' — означает "не переходить на другие файловые системы", искать только на указанной.
''-quit'' — останавливает find после первого совпадения.
''2>/dev/null'' — убирает ошибки доступа (Permission denied).

==== Не знаю каталог ====

Надо искать от корня системы, но надо учесть, что это будет долго и ресурсоёмко, особенно на больших дисках:

''stat "$(sudo find / -xdev -inum 32506352 -print -quit 2>/dev/null)"''

Если надо искать по всем дискам, надо убрать параметр ''-xdev'':

''stat "$(sudo find / -inum 32506352 -print -quit 2>/dev/null)"''

Если вообще не знаем, где находится файл и надо искать везде, разумно проверять примонтированные файловые системы по очереди. Скрипт запускать из-под ''sudo'': 

''df --output=target | tail -n +2 | while read -r mountpoint; do''
	''echo "Проверка в: $mountpoint"''
	''result=$(find "$mountpoint" -inum 32506352 -print -quit 2>/dev/null)''
	''if''  ''-n "$result"'' ''; then''
		''stat "$result"''
		''break''
	''fi''
''done''

Скрипт пройдётся по всем точкам монтирования (/, /home, /mnt/... и т.д.) и остановится на первом совпадении.

См. [[+alias]]
