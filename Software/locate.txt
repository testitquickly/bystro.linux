Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2024-09-13T23:51:50+03:00

====== locate ======

[ @debian @files @search @locate ]

Мощная утилита для поиска файлов названию (но не по их содержимому) в единой маленькой базе данных.

Казалось бы, зачем это нужно, ведь для поиска есть ''find'', который умеет искать не только файлы по их названию, но и по их содержимому. Но ''find'' буквально ищет по диску, это долго, это нагружает процессор и диски. А ''locate'' работает быстро потому, что он сперва индексирует файлы к себе в отдельный файл базы данных, и выполняет поиск файлов внутри своей базы, а не по диску IRL. Скорость работы несопоставима.

Надо только учитывать, что базу данных надо регулярно обновлять, потому что учтенные в ней файлы могут отсутствовать (удалены, перенесены или переименованы). ''locate'' можно запускать по крону или вручную. 

Также ВНЕЗАПНО невозможно перенести базу данных на другой ноутбук и использовать её.

Ещё важно учесть, что есть несколько версий locate:

''locate --version''

Если в ответ пришло 

'''
locate (GNU findutils) 4.9.0
Copyright (C) 2022 Free Software Foundation, Inc. 
'''

и так далее, то этот ''locate'' на самом деле это '''find -name''', и никакой базы для этой утилиты нет, а при вызове ''locate'' происходит поиск в реальном времени по файловой системе. Разумно этот псевдо-''locate'' удалить и поставить ''plocate'' — это более современная версия. Есть ещё устаревающий ''mlocate'', про него можно не думать.

''sudo apt purge locate && sudo rm /etc/updatedb.conf && sudo apt install plocate''

В дальнейшем вызов утилиты ''plocate'' делается через тот же алиас ''locate''. Мне показалось проще сделать алиасы со словом ''search''.

Для маленьких баз с вхождениями до 100 000 это работает быстро даже на слабых компьютерах (старые NAS). Если в поиске будет по несколько миллионов вхождений, тогда ''plocate'' с фильтрацией «на лету» отпадает.

===== Создать базы данных =====

По-умолчанию в базу данных ''plocate'' записываются (почти) ВСЕ файлы со всех дисков от корня системы. Лучше указать явно, содержимое каких каталогов надо индексировать.

Но есть засада — ''plocate'' не умеет индексировать сразу несколько каталогов. Только по-одному:

''sudo updatedb -o "/home/users/myUser/locateDB/v1.db" -U "/srv/dev-disk1/folder_1"''

Кавычки нужны на случай пробелов в пути.

Но я хочу искать файлы из трех разных каталогов, которые могут быть расположены на разных дисках. 

Для этого надо 
* сделать отдельную базу данных для каждого каталога, 
* сохранить все индексные файлы в один каталог,
* сделать отдельную функцию, которая будет выполнять поиск по всем индексным файлам

===== Сделать алиасы для функций locate =====

В ''~/.bashrc'' добавить:

'''
# === Обновление индексов ===
'''

'''
locateIndexes=/home/users/astenix/locateDB

searchupdate() {
	sudo updatedb -o "$locateIndexes/v1.db" -U "/srv/dev-disk1/folder_1"
	sudo updatedb -o "$locateIndexes/v2.db" -U "/srv/dev-disk2/folder_2"
	sudo updatedb -o "$locateIndexes/v3.db" -U "/srv/dev-disk2/folder_3"
	echo -e "\n\tИндексы обновлены"
}
'''

Следует помнить, что для ''locate'' «звёздные войны» и «звездные войны» это такие же разные слова, как «снайпер» и «sniper».  Есть смысл рассмотреть замену всех «ё» на «е»:

{{{code: id="replace_e" lang="sh" linenumbers="False"
find "/path/to/folder" -depth -name '*[Ёё]*' -execdir bash -c 'n="${0//Ё/Е}"; n="${n//ё/е}"; [ "$n" != "$0" ] && mv -T -- "$0" "$n"' {} \;
}}}

Дальше добавим две функции с произвольными короткими именами:

==== **1)** **search** ====

Условно быстрый, регистронезависимый поиск, но или по одному слову, или по нескольким, если они идут подряд.
* "''search смертельное''" — будут найдены все файлы с названием «Смертельное оружие…»
* "''search смертельное оружие''" — будут найдены все файлы с названием «Смертельное оружие…»
* "''search оружие смертельное''" — ничего не будет найдено

''# === Очень быстрый поиск по одному слову ===''

	''# Выполнить поиск по трём базам v1.db, v2.db, v3.db;''
	''# Поиск регистронезависимый;''
	''# Можно искать несколько слов, но только подряд''
		''# "search смертельное оружие" найдёт''
		''# "search оружие смертельное" ничего не найдёт''

''search() {''
	''if [ "$#" -eq 0 ]; then''
		''echo "Usage: search <pattern1> [pattern2 ...]"''
		''return 1''
	''fi''

	''local pattern="$*"''

	''echo -e " "''

	''local filtered''
	''filtered=$(for db in $locateIndexes/v{1,2,3}.db; do''
		''plocate -d "$db" "" 2>/dev/null''
	''done | grep -i "$(printf '%s' "$pattern" | sed 's/ /.* /g')" | sort -u)''

	''# Нумерация и вывод''
	''printf '%s\n' "$filtered" | nl -n ln -w 1 -s") "''
''}''

Надо сказать, что всего лишь поисковый запрос к базе типа

''plocate -d /abc/v1.db искомое_слово''

всегда будет работать молниеносно, потому что ему не надо вынимать из базы всё содержимое в память и потом фильтровать результаты, поиск происходит по индексу базы, и этого должно быть достаточно. Но ''plocate'' не умеет искать регистронезависимо, да еще с несколькими словами, поэтому:
* или скорость поиска — через матерщину по поводу неподходящего регистра буква, 
* или регистронезависимость запросов.

Второе ценнее, поэтому здесь происходит много всякого
* полная выгрузка каждой базы ''*.db'' в память, поочередно.
* цикл ''for db in ...'' запускает ''plocate -d "$db" ""'' — команда без запроса ("") выводит ВСЕ пути из базы.
* для каждой базы происходит полная печать всех путей к файлам.
* затем общий поток всех путей передаётся в ''grep -i'' для фильтрации.
* в конце ''sort -u'' удаляет дубликаты.
* и еще выполняется нумерация строк.

Если строк больше 190, на один экран они могут не поместиться. Решение:

''search слово | less''

Выход по клавише “q”.

==== 2**)** **search2** ====

Заметно медленный, но более детальный поиск. Регистронезависимый, можно искать несколько слов подряд и даже в разном порядке 
* "search оружие смертельное" найдёт «Смертельное оружие» и все его производные;


''# === Медленный поиск по нескольким словам ===''

	''# Выполнить поиск по трём базам v1.db, v2.db, v3.db;''
	''# Поиск регистронезависимый;''
	''# Можно искать несколько слов подряд и в разном порядке'' 
		''# "search оружие смертельное" найдёт «смертельное оружие»;''

''search2() {''
	''if [ "$#" -eq 0 ]; then''
		''echo "Usage: fastsearch <word1> [word2 ...]"''
		''return 1''
	''fi''

	''local dbs=(''
		''$locateIndexes/v1.db''
		''$locateIndexes/v2.db''
		''$locateIndexes/v3.db''
	'')''

	''# Слить всё сразу и отсортировать уникально''
	''local allpaths''
	''allpaths=$(for db in "${dbs[@]}"; do''
		''plocate -d "$db" "" 2>/dev/null''
	''done | sort -u)''

	''# Последовательно фильтруем по каждому слову (фиксированный регистронезависимый поиск)''
	''local filtered="$allpaths"''
	''for word in "$@"; do''
		''filtered=$(printf '%s\n' "$filtered" | grep -iF -- "$word")''
	''done''

	''# Нумерация и вывод''
	''printf '%s\n' "$filtered" | nl -n ln -w 1 -s") "''
''}''

===== Проверить количество индексированных файлов =====

Сделать поиск //пустоты// (можно какое-то слово, но тогда результат будет по словам) и запросить итоговую цифру:

{{{code: id="empty_search" lang="sh" linenumbers="False"
search '' | wc -l
}}}

Можно в каталог с индексами положить sh-скрипт (сделать его исполняемым), который покажет статистику для каждой базы данных:

{{{code: id="plocate_stats" lang="sh" linenumbers="True"
#!/bin/bash

DBPREFIX="/home/users/astenix/locateDB"
DBFILES=("$DBPREFIX/v1.db" "$DBPREFIX/v2.db" "$DBPREFIX/v3.db")

for DB in "${DBFILES[@]}"; do
  if [ ! -f "$DB" ]; then
    echo "База не найдена: $DB"
    continue
  fi

  echo "Статистика базы: $DB"
  TOTAL=$(locate -d "$DB" '' | wc -l)
  echo "  Всего путей: $TOTAL"
  echo "  Первые 10 путей:"
  locate -d "$DB" '' | head -n 10
  echo
done

}}}

===== Поиск файлов =====

''locate abc.txt''

''locate *.txt''

==== Поиск без учета регистра буква ====

''locate -i abc.txt''

==== Искать только среди существующих файлов ====

Этот параметр заставляет ''locate'' сперва проверить, есть ли на диске каждый файл, который должен быть показан в результатах поиска. То есть, условно превращаем ''locate'' в ''find''. Но нагрузка на процессор всё равно будет меньше, чем при явном использовании ''find''.

''locate -e *.txt''

==== Посчитать количество найденных файлов ====

Выводит только число.

''locate -c abc.txt''

==== Поиск по частичному совпадению ====

Так ''locate'' работает по-умолчанию. 

''locate reach''

выведет всё, что содержит ’''reach''’ внутри, например, ’''reacher''’ или ’''preacher''’.

==== Искать только указанные символы ====

Надо найти файлы из сериала 'Reacher'. Но на диске полно аудиофайлов из Pulp Fiction «Son of a preacher man», а поиск по «reacher» выводит ВСЕ файлы, в названии которых есть этам комбинация символов. 

Решение:

''locate reacher | grep -iw 'reacher'''

Можно сделать функцию которая превратит вызов в одно слово

	''# сокращение поиска locate строго по одному слову''
''l() {''
	''if [[ -z $1 ]]; then''
		''echo "Usage: search_word <word>"''
		''return 1''
	''fi''

	''locate "$1" | grep -iw "$1" | less''
''}''

Положить её в ''~/.bashrc'' и обязательно перечитать этот файл

''source ~/.bashrc''

Теперь поиск будет происходить так:

''l reacher''

Пролистывать ответы поэкранно клавишей “Space”. Если в ответ будет слишком много строк — выход из пролистывания по клавише “q“.

==== Комбинировать поисковые слова ====

Вот этот запрос показал мне набор книг про Ричера (книги в англ.):

''locate fiction | grep -iw 'reacher'''

==== Ограничить вывод списка найденных файлов ====

Пролистывать экраны с результатами поиска:

''locate abc.txt | less''

Пролистывать ответы поэкранно клавишей “Space”. Если в ответ будет слишком много строк — выход из пролистывания по клавише “q“.

Просто вывести на экран 10 строк:

''locate -n 10 *.txt''

==== Комплесный поиск через регулярные выражения ====

Делается через ''--regex''.

Найти все файлы с расширением ''.mp4'' А ТАКЖЕ ''.avi'':

''locate --regex -i "(\.mp4|\.avi)"''
