Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2024-10-26T19:40:30+03:00

====== Симлинки и хардлинки ======

[ @теория @symlink @hardlink @inode ]

===== Что такое файл? =====

Любой файл/каталог (каталоги тоже файлы, но особого формата) — это набор каких-то данных — нулей и единиц, которые записаны на одном или нескольких секторах на диске, последовательно — рядом, или в разных местах.

Каждый сектор или объявлен свободным для записи (даже если на нём есть какая-то упорядоченная информация), или принадлежащим к какой-то группе секторов.

Когда сектор на диске (один или множество) группируется, в системе делается объявление о том, что «к определенной группе отныне относится вот этот сектор (и этот, и этот, и вот этот…)». 

К каждой группе секторов прилагается её описание. Это описание называется Индексный Дескриптор, в оригинале Index Descriptor, оно же — //inode.// Это технический набор метаданных файла, включая размер файла, его местоположение, разрешения, владельцев и т.д. — всё, кроме имени и содержимого файла.

А операционная система определяет файлы на диске не по имени, как это привычно нам, а через Индексный Дескриптор — //inode.//

Почему так: содержимое файла уже записано в секторах диска, последовательно или вразнобой. А имя файла — отдельная абстракция в системе, про которую будет сказано позже.

Метаданные — это только //техническая// информация о файле, без его имени и содержимого:

	* Тип объекта (файл, каталог, символическая ссылка и т.д.)
	* Права доступа (чтение, запись, выполнение)
	* ID владельца и группы
	* Размер файла
	* Временные метки (создание, последняя модификация, последний доступ)
	* Кол-во ссылок на файл
	* Адреса блоков данных, где фактически хранится содержимое файла на диске

А ещё у операционной системы есть Dentriy (directory entry) – директория, она же каталог (folder). Это тоже файл, но специфичный — он или «пустой», или к нему «приписаны» другие файлы и каталоги, которые могут находится последовательно на нескольких секторах, а могут быть разбросаны по всему диску.… То есть, каталоги — это тоже файлы. И каждый inode в каждом каталоге должен быть уникальным.

Когда файл создают, операционная система связывает имя файла/каталога с уникальным inode. Точнее, само имя хранится в каталоге, а inode указывает на физические блоки, в которых находится содержимое файла. Это позволяет системе 
* отличать содержимое файла от его имени 
* и поддерживать несколько ссылок на один и тот же файл — каждая «ссылка на файл» указывает на один и тот же inode.

Увидеть inode файла:

''ls -i /home/astenix/test.txt''

Пример ответа:

''7734848 /home/astenix/test.txt''

Циферки — это указатель места (точнее, область) на диске — тот самый inode.

Собственно, на вопрос «Что такое файл?» единственно корректным ответом будет «Файл — это ссылка на inode».

	Одна из теоретических проблем — inode могут «закончиться», и нельзя будет создать новый файл или каталог на устройстве, даже если там достаточно свободного места. При этом уже имеющиеся файлы можно полноценно изменять. На практике хз, бывает ли.

===== Что такое ссылка на файл? =====

Есть условность, которую надо знать и учитывать — в Linux у каждого файла/каталога всегда только один inode, но у одного файла/каталога может быть одновременно //несколько// имён.

==== Хардлинк ====

С точки зрения операционной системы «имя файла» — это //hardlink//, «жёсткая ссылка». На диске есть набор информации (нули и единицы в секторах диска), и у этого набора есть «имя» — хардлинк.

Хардлинк указывает на определенный inode. То есть, имя файла — это хардлинк на inode. А значит файл — это ссылка на определённый inode.

Можно сделать несколько хардлинков на один и тот же inode. Для системы они все будут равноценны. Для человека это выглядт как «есть несколько файлов, у которых одно и то же содержимое». 

Можно сказать иначе: когда у одного файла есть два и более имени, которые указывают на один и тот же inode, то это два (и более) хардлинка.

Зачем это нужно? Это даёт возможность обращаться к одному и тому же файлу из разных каталогов и из разных userspace да под разными именами. Предположим, что на сервере в общем доступе находится файл «dailyReports.txt» Я могу в своём /home сделать хардлинк на этот файл и назову его «Отчёт.txt»; другой пользователь на том же компьютере в своём /home назовёт этот же файл (точнее, ссылку к нему) — «Анекдоты.txt», третий назовёт тот же файл «Важные данные.txt»… Ну или не txt, а файл базы данных — sql. Файл один и тот же, а названия у него разные. И каждый пользователь, который будет редактировать как будто бы разные файлы, а на деле — один и тот же.

	Можно в одном каталоге сделать два хардлинка на один и тот же файл из другого каталога. Можно даже сделать хардлинк на файл в том же каталоге, что и оригинал (незачем, но можно).

Для пользователя хардлинк на файл — это файл, который можно читать, редактировать и перемещать. Если не знать, что перед тобой хардлинк, то ничего об этом не подскажет, при редактировании хардлинка происходит редактирование оригинального файла.

Если оригинальный файл будет переименован или перенесён в другой каталог — хардлинк на него останется тем же и будет открывать переименованный/перемещенный файл так, словно никто ничего не менял. 

Даже если оригинальный файл будет удалён (inode будет помечен как «в этот сектор можно записывать новые данные», но перезаписывать этот сектор новыми файлами будет запрещено) — хардлинк на него останется, и юзеры будут открывать «несуществующий» файл так, словно никто ничего не удалял. Удаляется только dentry, а сам inode и данные файла НЕ удаляются, потому что на него всё ещё ссылается существующий хардлинк. 

В MC после редактирования оригинального файла при сохранении появляется вопрос — «Файл имеет жёсткие ссылки. Отсоединить перед сохранением?». Если сказать да — изменения в файле не будут отображаться при открытии файла через хардлинк. А хардлинк вроде бы откроет тот же файл на редактирование, но изменения в нём не будут отображаться (нет ссылки — нет изменений). На самом деле хардлинк начинает указывать на новый inode, и будет сохранять все изменения в новом файле. Вполне резонно, что может возникнуть путаница с тем, кто кто-то клянётся, что записал в файл что-то новое, а кто-то открывает этот же файл, но изменений не видит. Оба одновременно правы…

Хардлинки можно переносить в разные каталоги — при этом на жёстком диске сам файл/каталог, на который сделана ссылка, останется на месте.

И даже при удалении одного из имён/хардлинков, файл физически остаётся на диске, но только до тех пор, пока в системе есть другие имена для этого же файла.

	Если я у себя удалю файл «Отчёт.txt» — его оригинал «dailyReports.txt» останется, и другие пользователи будут всё так же редактировать его под соответствующими именами — «Анекдоты.txt» и «Важные данные.txt».

	Если я сделаю в своих каталогах несколько хардлинков на файл «dailyReports.txt», и удалю один из них — оригинал останется на месте.

Но если все пользователи, у которых есть хардлинки на этот файл, эти самые хардлинки у себя удалят — вот тогда и оригинальный файл будет удалён с сервера (точнее, с того места на жёстком диске, где он находился). У inode нет хардлинка — сектора свободны, файл не существует.

Важное условие: нельзя сделать хардлинк на каталог. Хардлинки — это всегда только имена файлов.

См. [[Debian:HowTo:Сделать:hardlink]]

==== Симлинк ====

Symbolic link, он же сокращённо «symlink» — это ссылка не на //inode// файла, а на имя файла — на //хардлинк//. 

	То есть, при обращении к симлинку происходит обращение к хардлинку, который сообщает, к какому именно inode надо обратиться.

Внешне симлинк тоже не распознать — файл и файл, но в [[Midnight Commander]] они нарочно отображаются с дополнительными символами:
* у симлинка на файл первый символ в имени — “''@''” (собачка).
* у симлинка на каталога первый символ в имени — “''~''“ (тильда).

Симлинки, как и хардлинки, тоже можно свободно переносить в разные каталоги — оригинал останется на месте.

Основная разница между симлинком и хардлинком в том, что происходит с оригинальным inode при удалении хардлинка и симлинка. Если хардлинки делает один пользователь, и хардлинк тоже один, то при удалении хардлинка оригинальный файл тоже будет удалён (inode будет помечен как свободный). А при удалении симлинков с оригиналом файла ОДНОЗНАЧНО ничего не происходит:
* при чтении/редактировании симлинка открывается на чтение/редактирование оригинал,
* при переименовании или удалении симлинка оригинал остаётся на месте — однозначно и безопасно,
* при переименовании или удалении оригинального файла симлинк остаётся, но выглядит как файл, который «невозможно открыть», ведь имени, на которое было указание, больше нет. В MC в этом случае первый символ в названии симлинка превращается в восклицательный знак — удобная подсказка.

А если снова создать на месте старого файла новый файл, то симлинк снова заработает.

И да, симлинки тоже можно именовать как угодно — ссылка на оригинальный файл/каталог остаётся неизменной.

См. [[Debian:HowTo:Сделать:symlink]]

===== Примеры =====

В Linux можно запускать любой скрипт в консоли из любого каталога как обычную команду, если сделать на нужный скрипт симлинк в каталоге с бинарниками.

==== Debian update ====

Например, я собрал последовательнось команд для обновления Debian и положил его в файл „''/home/mySettings/myScripts/debian/debian_update_and_upgrade.sh''”. 

	Сделал скрипт.

В консоли можно запустить этот скрипт так:

''/home/mySettings/myScripts/debian/debian_update_and_upgrade.sh''

Или сперва зайти в каталог с файлом

''cd /home/mySettings/myScripts/debian/''

и уже оттуда его запустить:

''./debian_update_and_upgrade.sh'' 

А ещё можно сделать символическую ссылку на этот файл, положить её в какой-то каталог «внутри профиля пользователя» и вызывать её в консоли как консольную команду. 

	Или можно сделать такой симлинк доступным для всех пользователей на компьютере (разумно, когда общий сервер).

У симлинка может быть любое имя, отличное от оригинального файла, и иногда это приносит дополнительное удобство. Например, оригинал будет называться „debian_update_and_upgrade.sh”, а симлинк можно называть очень сокращенно, например, „''debup''” — расширение для файла в этом случае вообще не имеет значения.

	Или „''updeb''”.
	Или „''dp''”.
	Или „''updatemazafaka''”.
	Или все сразу.

==== Cсылки на программное обеспечение ====

Например, пишем программу, которая обращается к исполняемым файлам Java. Где они находятся?

В консоли при вызове

''java''

происходит пробег по нескольким каталогам и файлам — да, симлинк может ссылаться на другой симлинк, который ссылается на третий симлинк…

1. Читаем ''/usr/bin/java'' — это не просто файл без расширения, это симлинк на ''/etc/alternatives/java''
2. Читаем ''/etc/alternatives/java'' — это симлинк на ''/usr/lib/jvm/java-17-openjdk-amd64/bin/java''
3. Читаем ''/usr/lib/jvm/java-17-openjdk-amd64/bin/java'' — это симлинк на ''/usr/lib64/ld-linux-x86-64.so.2''
4. Читаем ''/usr/lib64/ld-linux-x86-64.so.2'' — это симлинк на ''/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2'' с набором дополнительных инструкций
5. Читаем, если не надоело, файл ''/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2''…

Версии java постоянно меняются, меняется и содержимое файлов, и их расположение. Но через систему симлинков на стороне пользователя вызов ''java'' всегда происходит через одну и ту же команду. А вызов 

''java --version''

с ответом вроде

''openjdk 17.0.13 2024-10-15''
''OpenJDK Runtime Environment (build 17.0.13+11-Debian-2deb12u1)''
''OpenJDK 64-Bit Server VM (build 17.0.13+11-Debian-2deb12u1, mixed mode, sharing)''

это же чтение содержимого переменных из разных файлов, в том числе и из ''/usr/lib/jvm/java-17-openjdk-amd64/release'':

''IMPLEMENTOR="Debian"''
''JAVA_RUNTIME_VERSION="17.0.13+11-Debian-2deb12u1"''
''JAVA_VERSION="17.0.13"''
''JAVA_VERSION_DATE="2024-10-15"''
''…''

При выпуске следующей версии — ''java-18'' — исполняемые файлы уже будут находиться в каталоге с другим названием, и информацию о версии придется читать из другого файла в каталоге с другим названием — ''/usr/lib/jvm/java-18-openjdk-amd64/release'' Однако благодаря системе перекрёстных хард и симлинков команда обращения будет прежняя.

Третий пример характерен для древних времён, когда на дисках всегда было ОЧЕНЬ мало места. Есть набор файлов, которые находятся в разных каталогах. И надо собрать их них условный плэйлист (сделаем прямую аналогию с аудиофайлами). Можно скопировать все нужные нам файлы в один новый каталог, но это значит, что на диске станет меньше свободного места. А можно в этот новый каталог положить только симлинки на нужные файлы, которые лежат в разных каталогах — если таких файлов много, то получится однозначная экономия места на hdd.

==== linkfolder ====

А вот так можно делать в папке своего профиля симлинк на каталог, в котором находишься

''ln -s "$(realpath .)" ~/"$(basename "$PWD")"''

Почему ''realpath'' — потому, что иногда находишься в каталоге, который уже является симлинком. Лучше ссылаться на оригинал.

Есть смысл сделать для этого дела алиас в ~/.bashrc

''alias linkfolder='ln -s "$(realpath .)" ~/"$(basename "$PWD")"'''

===== Узнать файл по inode =====

Предположим, что я знаю inode, и надо понять, какой файл на него указывает. 

==== Знаю каталог ====

Для этого хорошо бы знать, в каком каталоге находится файл:

''stat "$(find /home/astenix/test -xdev -inum 32506352 -print -quit 2>/dev/null)"''

Здесь:

''-xdev'' — означает "не переходить на другие файловые системы", искать только на указанной.
''-quit'' — останавливает find после первого совпадения.
''2>/dev/null'' — убирает ошибки доступа (Permission denied).

==== Не знаю каталог ====

Надо искать от корня системы, но надо учесть, что это будет долго и ресурсоёмко, особенно на больших дисках:

''stat "$(sudo find / -xdev -inum 32506352 -print -quit 2>/dev/null)"''

Если надо искать по всем дискам, надо убрать параметр ''-xdev'':

''stat "$(sudo find / -inum 32506352 -print -quit 2>/dev/null)"''

Если вообще не знаем, где находится файл и надо искать везде, разумно проверять примонтированные файловые системы по очереди. Скрипт запускать из-под ''sudo'': 

''df --output=target | tail -n +2 | while read -r mountpoint; do''
	''echo "Проверка в: $mountpoint"''
	''result=$(find "$mountpoint" -inum 32506352 -print -quit 2>/dev/null)''
	''if''  ''-n "$result"'' ''; then''
		''stat "$result"''
		''break''
	''fi''
''done''

Скрипт пройдётся по всем точкам монтирования (/, /home, /mnt/... и т.д.) и остановится на первом совпадении.

См. [[Debian:HowTo:Сделать:alias]]
