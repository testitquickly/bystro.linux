Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2025-08-11T14:56:29+03:00

====== GraphViz ======

@diagram @graphviz @mermaid @zim 

Эта система происходит из того же мира, что и [[LaTeX]] — пользователь только описывает узлы и ребра диаграммы, а «неведомая магическая сила» сама их расставит так, как //ей// покажется лучше. 

“''Graphviz DOT''” (так оно называется полностью) — язык описания диаграмм, который пришёл из мира науки, мощный и гибкий, умеет делать ооооочень сложные графы, рендерится через командную строку, генерирует изображения в PNG, SVG, PDF и др. Эдакий TikZ, но без [[LaTeX]] за спиной.

Также можно собирать диаграммы по текстовому описанию через «MermaidJS» — тоже язык описания диаграмм с почти аналогичным синтаксисом, но он изначально был ориентированный рендеринг в браузере, потому что JavaScript. Ничего не мешает освоит и то и это.

===== Установить =====

* [[Debian:Install:GraphViz]]

===== Использовать =====

Пример кода диаграммы, который будет находиться в условном файле ''abc.dot'':

{{{code: id="diagram_example" lang="dot" linenumbers="True"
digraph СистемноеМышление {
	rankdir=TB; // направление раскладки графа: T — top (сверху), B — bottom (снизу)
	bgcolor="#1b1e20"; // Фон всей диаграммы — тёмно-серый

	// Заголовок: отдельный узел с особым рангом "source"
	title [label="Дума сэнсэя Иванова", shape=plaintext, fontsize=22, fontcolor="#cf9f50"];
	// Невидимые узлы слева и справа для центрирования заголовка
	left [label="", style=invis];
	right [label="", style=invis];
	// Чтобы все три были на одном уровне (ранге) — заголовок центрируется между ними
	{ rank=source; left; title; right; }

	// Настройки всех узлов
	node [
		fontcolor="#b2b2b2" // цвет текста и рамок (светло-серый) https://graphviz.org/doc/info/colors.html
		color="#b2b2b2" // цвет рамок (границ) узлов
		fillcolor="#1b1e20" // фон узлов — тёмно-серый
		style=filled // стиль заливки узла — залить цветом из fillcolor
		fontname="Ysabeau"
		fontsize="16"
	];

	// Настройки всех рёбер
	edge [
		arrowhead=open // глобальный тип стрелок https://graphviz.org/docs/attr-types/arrowType/
		color="#b2b2b2" // цвет линий и шрифта (светло-серый)
		fontname="Ysabeau"
		fontsize="16"
	];

	// нельзя сразу объявлять и соединять узлы, как в Mermaid
	// надо сперва расписать все сущности
	
	// можно задать отдельно форму каждому узлу: id2 [shape=box, label="Невод закинут в море"];
	// а можно их группировать 
	node [shape=octagon];
	S [label="Происходит жизнь"] // S = Start
	E [label="Разговор исчерпан"]; // E  End
		
	node [shape=none];
	сила_воли [label=<<s>Сила Воли</s>>]
	принуждение [label=<<s>Принуждение</s>>];
	проверка_боем [label="проверка боем", shape=box];

	node [shape=note];
	id1 [label="Самурай всё понимает", comment="I am node id1"];
	id2 [label="Невод закинут в море"];
	rybka [label="Мерзнет пингвин"];
	biblioteka [shape=plaintext, label="Понял в тишине библиотеки"];
	bookIsClosed [label="Книга недолго открыта"];
	
	node [shape=underline];
	как_думать [label="Самурай без меча"];
	gameOver [label="Демоны спёрли дыхание"];
	listOfEvents [label="• Некуда спешить\n• Не о чём думать\n• Начинается дождь", fontsize=12, fontcolor="Coral", color="DarkOrange"];
	
	// затем узлы можно соединять в самых причудливых сочетаниях
	
	сила_воли -> S;
	принуждение -> S;
	проверка_боем -> S;
	
	как_думать -> biblioteka [label=<<font color="yellow" point-size="13">Спросил у <i>ясеня</i></font>>];
	biblioteka -> listOfEvents;

	S -> id1;
	
	// чтобы задать стиль отдельной стрелке, ноды одного пути надо разнести "две отдельно"
	id1 -> id2 [arrowhead=tee]; 
	
	// можно соединять узлы по-отдельности (1 -> 2; 2 -> 3…), а можно последовательно (1 -> 2 -> 3…)
	id2 -> rybka -> listOfEvents -> E;
	
	// можно использовать один узел в нескольких связках
	listOfEvents -> gameOver -> bookIsClosed;
	
}
}}}

Сборка:

''dot -Tpng abc.dot -o abc.png''

Результат:

{{./diagram.png?type=diagram}}

===== Общий подход к построению диаграмм =====

1. объявить тип диаграммы.
2. объявить свойства диаграммы — глобальное оформление, узел-заголовок
3. объявить группы узлов — по форме (shape), по цвету, …
4. объявить кластеры узлов — они будут отображаться маленькой группой в отдельной рамке 
5. объявить узлы — названия (можно и кириллице), label, оформление отдельных узлов
6. начать соединять объявленные ранее узлы в нужных комбинациях

Иногда непременно захочется, чтобы «вот это было справа, и чтобы повыше того…», и начинается колдование. Таких желаний надо всячески избегать. Рекомендуется принять предлагаемое оформление и вносить изменения только на уровне ручного управления направлением стрелок:

''Повторяемость -> Планы [tailport=w, headport=w, minlen=3];''

Здесь:

* n, e, s, w — стороны захода стрелки к узлу (по компасу)
* tailport - направление тела стрелки, 
* headport - направление головы стрелки, 
* minlen - длина стрелки

===== Типы диаграмм =====

В Graphviz есть несколько движков компоновки графов (layout engines), которые определяют, как узлы и связи будут размещены на диаграмме, и при сборке сперва нужно указать используемый. Они разные, потому что у каждого свой подход к оформлению диаграммы:

* dot — для ориентированных графов (обычно рисует иерархию сверху вниз или слева направо). Считать стандартным
* neato — для неориентированных графов, делает "пружинную" раскладку по метрике
* fdp — тоже "пружинная" раскладка, но алгоритм другой (force-directed placement)
* sfdp — как fdp, но масштабируется на большие графы
* twopi — круговые диаграммы ("от центра к окружности")
* circo — ещё один круговой вариант

Разумно всегда указывать движок в самом начале команды сборки, но это можно сделать и через отдельный параметр.

Можно смешивать неспешиваемое и собирать неориентированнй граф ''dot'' (он же ''graph'') через параметр ''-Kfdp'', но стандартный ''dot'' рассчитан именно на иерархии, а не на свободное расположение узлов, поэтому диаграмма может получиться некрасивой.

==== dot ====

Ориентирован на ориентированные графы (с направленными связями): схемы зависимостей, диаграммы потока, DAG (Directed Acyclic Graph) — классический выбор для impact analysis.

Алгоритм: слой за слоем (hierarchical / Sugiyama method). Узлы выстроены сверху вниз, стрелки можно направлять и вниз, и вверх.

Внешний признак: объявление ''digraph'', стрелки между узлами.

Сборка:

''dot -Tpng abc.dot -o abc.png''

Примеры:

1)

{{{code: id="simple_dot" lang="dot" linenumbers="True"
digraph G {
	A -> B;
	B -> C;
	}
}}}

{{./diagram-dot-1.png?id=diagram-dot-1}}

2)

{{{code: id="impact_graph" lang="dot" linenumbers="True"
digraph ImpactGraph {
	node [shape=ellipse, style=filled, color=lightgreen];
	Invoice -> Payment [label="depends"];
	Invoice -> DB [label="updates"];
	Payment -> DB;
}
}}}

{{./diagram-dot-2.png?id=diagram-dot-2}}

3) 

{{{code: id="complex_digraph" lang="dot" linenumbers="True"
digraph ImpactGraph {
	// Настройки узлов
	node [shape=box, style=filled, color=lightblue, fontname="Arial"];
	edge [fontname="Arial", fontsize=10, color=gray];
	
	// Можно добавить группировки
	subgraph cluster_db {
		label="Database";
		DB;
		Payment;
	}

	subgraph cluster_services {
		label="Services";
		Invoice;
		NotificationService;
		Customer;
	}
	
	// Связки услов и указание зависимостей между ними (метки на стрелках)
	Invoice -> Payment [label="depends"];
	Invoice -> DB [label="updates"];
	Payment -> DB [label="reads/writes"];
	Invoice -> Customer [label="notifies"];
	Customer -> NotificationService [label="triggers"];

}
}}}

{{./diagram-dot-3.png?id=diagram-dot-3}}

==== neato ====

Для неориентированных графов: например, социальные связи или сети зависимостей без жёсткой иерархии или явного направления.

Алгоритм: force-directed. Узлы распределены равномерно и отталкиваются друг от друга, связи ведут себя как пружины, нет верх-низ, структура «распухает» в пространство..

Внешний признак: объявление ''graph'', между узлами не стрелки, а простые линии (смешивание типа стрелок ''--'' и ''->'' приведет к ошибке компиляции).

Сборка:

'''
neato -Tpng abc.dot -o abc.png
'''

1)

{{{code: id="simple_graph1" lang="dot" linenumbers="True"
graph G {
A -- B;
B -- C;
}
}}}

{{./diagram-neato-1.png}}

2)

{{{code: id="simple_graph2" lang="dot" linenumbers="True"
graph G {
A -- B -- C;
B -- D -- A;
}
}}}

{{./diagram-neato-2.png}}

==== fdp ====

Альтернатива neato, тоже для force-directed layout, но использует другой алгоритм оптимизации. Лучше справляется с ОЧЕНЬ большими графами, иногда быстрее сходится. Нужен, когда большие неориентированные графы, где neato «слипается» или узлы слишком близко.

Внешний признак: объявление ''graph'' с параметром ''layout=fdp;'', между узлами простые линии. 

В коде диаграммы можно //не указывать// параметр ''layout=fdp;'' но лучше указать, он прямо влияет на внутренние настройки ''force-directed layout'' и  без него диаграмма может выглядеть иначе.

Сборка:

'''
fdp -Tpng abc.dot -o abc.png
'''

1)

{{{code: id="fdp" lang="dot" linenumbers="True"
graph G {
	layout=fdp;
	
	A -- B;
	A -- C;
	A -- D;
	A -- E;
	A -- F;
	A -- G;
}
}}}

{{./diagram-fdp-1.png}}

2)

А это получится без указания layout.

{{{code: id="fdp" lang="dot" linenumbers="True"
graph G {
	
	A -- B;
	A -- C;
	A -- D;
	A -- E;
	A -- F;
	A -- G;

}
}}}

{{./diagram-fdp-2.png}}

==== twopi ====

Круговые диаграммы ("от центра к окружности").

Внешний признак: объявление ''graph'' с параметром ''layout=twopi'', между узлами простые линии. 

Сборка:

'''
twopi -Tpng abc.dot -o abc.png
'''

1)

{{{code: id="fdp" lang="dot" linenumbers="True"
graph G {
	layout=twopi;
	
	A -- B;
	A -- C;
	A -- D;
	A -- E;
	A -- F;
	A -- G;
}
}}}

{{./diagram-twopi-1.png}}

2)

Можно сделать на том же движке и стрелки (тут уже нужен ''digraph''):

{{{code: id="circle_arrows" lang="dot" linenumbers="True"
digraph G {
    layout=twopi;
    
    A -> B;
	A -> C;
	A -> D;
	A -> E;
	A -> F;
	A -> G;
}
}}}

{{./diagram-twopi-2.png}}

==== circo ====

1)

{{{code: id="fdp" lang="dot" linenumbers="True"
graph G {
	layout=circo;
	
	A -- B;
	A -- C;
	A -- D;
	A -- E;
	A -- F;
	A -- G;
}
}}}

{{./diagram-circo-1.png}}

===== Включить модуль в Zim =====

Когда GraphViz уже установлен в систему, его можно использовать внутри [[Zim]] через модуль «Вставка диаграмм»:

''Правка''
''> Параметры''
''> Модули''
''> Вставка диаграмм''

==== Вставить диаграмму ====

''Вставка''
''> Диаграмма'' 

Набрать код, проверить его корректность через «Предварительный просмотр». Если будут ошибки, картинка не появится.

После завершения редактирования к странице будет приложен файл ''*.dot'' и картинка:

* ''diagram.dot''
* ''diagram.png''

Если диаграмм будет несколько, файлы будут автоматически переименованы:

* ''diagram1.dot''
* ''diagram1.png''
* ''diagram2.dot''
* ''diagram2.png''

В процессе работы с диаграммами в Zim некоторые из них остаются, а другие удаляются автоматически. Но файлы некоторых «удаленных» диаграмм могут остаться на месте, их надо удалить вручную.

==== Отредактировать диаграмму ====

''Правой кнопкой по рисунку''
''> Редактировать''

===== Автоматизация сборки =====

Можно собрать максимально универсальный bash-скрипт, который:

* разрешает собирать диаграмму из ''*.dot'' в любом каталоге по команде “''gviz abc.dot''”
* подставляет для сборки внешний файл с общим стилевым оформлением
* автоматически определяет нужный движок:
	* по типу графа (graph → fdp, digraph → dot)
	* если в стилях есть layout=neato|fdp|twopi|circo → использует его
* создаёт PNG рядом с .dot файлом
* автоматически открывает результат в Graph View (интерактивное)

==== Вынести оформление диаграммы в отдельный файл ====

Если оформление начинает повторяться, есть смысл вынести общие места в отдельный файл ''*.dot'' 

{{{code: id="external_styles" lang="dot" linenumbers="True"
// == Общие настройки графа

# направление раскладки графа: T — top (сверху), B — bottom (снизу)
rankdir = TB;

# фон всей диаграммы — тёмно-серый
bgcolor = "#1b1e20";

// == Заголовок 

# отдельный узел с особым рангом "source"
title [label = "Дума сэнсэя Иванова", 
    shape = plaintext, 
    fontsize = 22, 
    fontcolor = "#cf9f50"];
# невидимые узлы слева и справа для центрирования заголовка
left [label = "", 
    style = invis];
right [label = "", 
    style = invis];
# чтобы все три узла были на одном уровне (ранге) — заголовок центрируется между ними
{ rank=source; left; title; right; }

// == Настройки всех узлов

node [
    fontcolor = "#b2b2b2" // цвет текста и рамок (светло-серый) https://graphviz.org/doc/info/colors.html
    color = "#b2b2b2" // цвет рамок (границ) узлов
    fillcolor = "#1b1e20" // фон узлов — тёмно-серый
    style = filled // стиль заливки узла — залить цветом из fillcolor
    fontname = "Ysabeau"
    fontsize = "16"
];

// == Настройки всех рёбер

edge [
    arrowhead = open // глобальный тип стрелок https://graphviz.org/docs/attr-types/arrowType/
    color = "#b2b2b2" // цвет линий и шрифта (светло-серый)
    fontname = "Ysabeau"
    fontsize = "16"
];

}}}

Указания из стилевого файла применяются каскадом, как в CSS. Действует правило «последнее объявление перекрывает предыдущее». То есть, если во внешнем стилевом файле указано:

{{{code: id="styles" lang="dot" linenumbers="True"
edge [
	arrowhead=open
	color="#b2b2b2"
	fontname="Ysabeau"
	fontsize="16"
];
}}}

а в файле с диаграммой подключить внешний стилевой файл, но //также// вставить свои указания про оформление какого-то элемента:

{{{code: id="styles" lang="dot" linenumbers="True"
edge [
	fontname="Arial"
	fontsize="10"
];
}}}

то в итоговом оформлении диаграммы будет использован шрифт Arial с размером 10.

Диаграммы бывают разными, поэтому какие-то управляющие команды надо использовать в каждом случае отдельно (например, rankdir = TB в круговых диаграммах не нужно). Разумно сделать несколько стилевых файлов для разных типов диаграмм и подключать их при необходимости:

''circo.st''
''dot.st''
''fdp.st''
''neato.st''
''twopi.st''

В каждом файле можно указать layout, который соответствует выбранному движку.

Подключение внешнего стилевого файла будет выполнено в итоговом bash-скрипте.

==== Сделать отдельный bash-скрипт ====

Перейти в каталог, в котором постоянно будет находиться bash-скрипт. Создать файл:

''mcedit GraphViz.sh''

Вставить:

{{{code: id="graphviz.sh" lang="sh" linenumbers="True"
#!/bin/bash

    # Универсальный Graphviz с авто-движком и стилями
    # разрешает собирать диаграмму из *.dot в любом каталоге по команде “gviz abc.dot”
    # 	см. алиас в ~/.bashrc 
    # подключает внешний файл стилей только если указано через комментарий // STYLES:
    # автоматически определяет нужный движок:
    # 	по атрибуту layout в стилевом файле, иначе по типу графа
    # создаёт PNG рядом с .dot файлом
    # открывает результат в Dot Viewer (xdot) в фоне
    # исходный .dot файл остаётся нетронутым
    # выводит информацию о выбранном стиле и движке

    # Usage: gviz abc.dot

# принимаем на вход имя файла
DOTFILE="$1"
if [[ -z "$DOTFILE" ]]; then
    echo "Использование: gviz abc.dot"
    exit 1
fi

if [[ ! -f "$DOTFILE" ]]; then
    echo "Файл $DOTFILE не найден"
    exit 1
fi

# полный путь к файлу
DOTFILE=$(realpath "$DOTFILE")
PNGFILE="${DOTFILE%.*}.png"

# проверяем, есть ли указание на подключение внешнего стилевого файла через комментарий
STYLES_LINE=$(grep -E "^// STYLES:" "$DOTFILE" | head -n1)
if [[ -n "$STYLES_LINE" ]]; then
    STYLES_NAME=$(echo "$STYLES_LINE" | cut -d: -f2 | tr -d ' ')
    STYLES="/полный/путь/styles/$STYLES_NAME"
    if [[ ! -f "$STYLES" ]]; then
        echo "Файл стилей $STYLES не найден"
        exit 1
    fi
    USE_STYLES=true

    # читаем layout из стилевого файла
    ENGINE=$(grep -Eo "layout=[a-z]+" "$STYLES" | head -n1 | cut -d= -f2)
    if [[ -z "$ENGINE" ]]; then
        echo "В файле стилей не указан layout. Используем fdp по умолчанию."
        ENGINE="fdp"
    fi
else
    USE_STYLES=false
    # если стиля нет, определяем движок по типу графа
    if grep -q "digraph" "$DOTFILE"; then
        ENGINE="dot"
    else
        ENGINE="fdp"
    fi
fi

# создаём временный dot файл для xdot
TMPDOT=$(mktemp /tmp/GraphViz_XXXX.dot)

# Генерация временного DOT с подставленными стилями
if $USE_STYLES; then
    awk -v styles="$STYLES" '
    {
        print
        if ($0 ~ /{/) { system("cat " styles) }
    }' "$DOTFILE" > "$TMPDOT"
else
    cp "$DOTFILE" "$TMPDOT"
fi

# Генерация PNG
"$ENGINE" -Tpng "$TMPDOT" -o "$PNGFILE"

if [[ $? -eq 0 ]]; then
    echo "Диаграмма $DOTFILE собрана с движком $ENGINE"
    if $USE_STYLES; then
        echo "Подключен внешний стилевой файл: $STYLES_NAME"
    else
        echo "Внешний стилевой файл не использовался"
    fi

    # открываем временный dot в xdot в фоне
    nohup xdot "$TMPDOT" >/dev/null 2>&1 &
else
    echo "Ошибка генерации диаграммы"
    rm -f "$TMPDOT"
    exit 1
fi
}}}

Сделать файл исполняемым

''chmod +x GraphViz.sh''

Сделать алиас на него в 

''mcedit ~/.bashrc''

Например “''dgr''”:

''alias dgr='/''__''полный/путь''__''/GraphViz.sh'''

Перечитать файл

''source ~/.bashrc''

В файле ''abc.dot'' надо указать подключение стилей из внешнего файла через строку, которая спрятана за комментарием, иначе в диаграмме появляются два ненужных узла. Важно: у строки с комментарием с указанием внешнего стилевого файла __не должно__ быть отступа от левого края. Пробел или таб превратит эту строку в простой комментарий.

Соответственно, если не нужно оформление, строку надо или убрать полностью, или отодвинуть от левого края.

{{{code: id="abc_file" lang="dot" linenumbers="True"
graph G {
// STYLES: neato.st

    applied;

    A -- B;
    A -- C;
    A -- D;
    A -- E;
}
}}}

В консоли в каталоге с файлом ''abc.dot'' выполнить:

''dgr abc.dot''

Будет создана картинка png с оформленной диаграммой, а такое готовая диаграмма откроется в окне Dot Viewer.

Учесть, что по-умолчанию Dot Viewer открывает на просмотр исходный код из файла ''*.dot'', и не может увидеть, что в файл подключен внешний стилевой файл — это просто строка с комментарием, который будет проигнорирован. Чтобы отобразить в Dot Viewer диаграмму с итоговым оформлением, bash-скрипт создаст временный файл *.dot в каталоге /tmp, насильно внедрит в него инструкции из внешнего стилевого файла и откроет этот результат в Dot Viewer.

===== Дизайн диаграмм =====

Практически всё форматирование текста в узлах делается на html, который надо обернуть в дополнительные ''<…>''

Изучить все возможности: https://graphviz.org/documentation/

==== Перечеркнуть текст ====

''сила_воли [label=<<s>Сила Воли</s>>];''

Можно применить ''shape = proteasesite'', но у узла также появится лишняя иконка.

==== Поменять размер шрифта ====

''listOfEvents [label="йцукен", fontsize=12];''

==== Поменять цвет текста ====

''listOfEvents [label="йцукен", fontcolor="Coral"];''

==== Поменять цвет узла ====

''listOfEvents [label="йцукен", color="DarkOrange"];''

==== Поменять цвет отдельных слов в узле ====

Это усложняет синтаксис, но разобраться можно:

''listOfEvents [label=<''
'''
	ОБЩИЙ ОБЗОР<BR/>
	<FONT COLOR="green4">
 	• сделано то…<BR/>
	• сделано сё…
	</FONT>
	>];
'''

==== Сгруппировать несколько узлов ====

{{{code: id="cluster_rassujdenie" lang="dot" linenumbers="True"
subgraph cluster_Рассуждение {
		label = <<font point-size="16" color="Gold">Рассуждение</font>>;
		color = "lightgrey";
		style = "rounded";

		Обзор -> Повторяемость;
		Повторяемость -> Обзор;
		Повторяемость -> Содрать_пластырь;
		Содрать_пластырь -> Повторяемость;
	}
}}}

Учесть, что это группирование условно, извне надо обратиться к определенному узлу внутри группы, обратить стрелку //к группе// невозможно, потому что кластер (subgraph cluster_...) сам по себе не является вершиной графа.

''Дискомфорт -> Обзор [tailport=e, headport=e, minlen=3];''

В данном случае от внешнего узла Дискомфорт пойдет стрелка к первому узлу в кластере Рассуждение — Обзор.

Для аккуратности зрительного представления можно управлять направлением ребра:

* ''tailport=e'' — с какой стороны света (квадрата) стрелка выходит от узла Дискомфорт
* ''headport=e'' — с какой стороны света (квадрата) стрелка зайдет к узлу Обзор
* ''minlen=3'' — минимальная длина стрелки

=== Обходные пути ===

== Оттенить стрелки ==

Лучший способ — задать цвет стрелок бледнее цвета узлов.

''node [shape=box, style=filled, fontname="Arial", fontsize=12, color=lightblue];''
''edge [fontname="Arial", fontsize=10, color=gray];''

Или для тёмной темы:

'''
node [color="#b2b2b2"];
edge [color="#535353"];
'''
	
Тогда «заход» стрелки в область кластера не воспринимается как «наезд».

== «Невидимый» узел ==

Создать внутри кластера «невидимый» узел — назовем его invisible. Основные свойства: 

''label="", style=invis, width=0''

{{{code: id="invisible_dot" lang="dot" linenumbers="True"
digraph G {
	rankdir=TB; // направление раскладки графа: T — top (сверху), B — bottom (снизу)
	bgcolor="#1b1e20"; // Фон всей диаграммы — тёмно-серый

	// Настройки всех узлов
	node [
		fontcolor="#b2b2b2" // цвет текста и рамок (светло-серый) https://graphviz.org/doc/info/colors.html
		color="#b2b2b2" // цвет рамок (границ) узлов
		fillcolor="#1b1e20" // фон узлов — тёмно-серый
		style=filled // стиль заливки узла — залить цветом из fillcolor
		fontname="Ysabeau"
		fontsize="16"
	];

	// Настройки всех рёбер
	edge [
		arrowhead=open // глобальный тип стрелок https://graphviz.org/docs/attr-types/arrowType/
		color="#b2b2b2" // цвет линий и шрифта (светло-серый)
		fontname="Ysabeau"
		fontsize="16"
	];
	
    subgraph cluster_Rassuzhdenie {
        label = <<font point-size="16" color="Gold">Рассуждение</font>>;
        color = "lightgrey";
        style = "rounded";

	// фиктивный узел для связей
        invisible [shape=point, label="", style=invis, width=0];
        Обзор -> Повторяемость;
        Повторяемость -> Обзор;
        Повторяемость -> Содрать_пластырь;
        Содрать_пластырь -> Повторяемость;
    }

    Дискомфорт -> invisible [lhead=cluster_Rassuzhdenie, minlen=3];
}
}}}

При обращении к нему обязательно указать параметр ''lhead'' с именем кластера.

И поставить его первым в кластере, что необязательно, но сделает его заметным.

Указать связь от внешнего узла к invisible.

Graphviz протянет стрелку к конкретному узлу, но внешне смотрится так, словно стрелка ведет к кластеру.

{{./diagram001.png?type=diagram}}

Не надо злоупотреблять этим приемом, появится множество «невидимых» узлов.

==== Стиль стрелок с прямыми углами ====

Как в органиграммах.

В начале диаграммы указать глобальный параметр

''splines=ortho;''

Можно «выпрямить» отдельные стрелки, но сперва надо учесть layout — ortho работает корректно для dot и neato, остальные движки могут затрещать:

{{{code: id="ortho_1" lang="dot" linenumbers="True"
digraph G {
    A -> B;              // обычное ребро
    B -> C [splines=polyline];   // индивидуальное ребро с обычными прямыми сегментами
    C -> D [splines=ortho];      // только это ребро с прямыми углами
}
}}}

Можно объединить несколько рёбер с одинаковым стилем, чтобы получить органиграмму, где часть связей с «прямыми» стрелками, а часть — со стандартными.

{{{code: id="ortho_2" lang="dot" linenumbers="True"
digraph G {
	subgraph cluster_ortho {
		splines=ortho;
		B -> C;
		C -> D;
	}
	A -> B; // другое ребро без ortho
}
}}}

==== Перенос строк в узле ====

Через символ ''\n''

===== О принципах =====

Я фанат UML.

После изучения UML я понял, что только фанаты UML разбираются в ромбиках и овалах, и помнят, чем они отличаются. Все остальные видят в этих диаграммах заявление типа «//Эй, смотрите, я разбираюсь в UML! А вы — нет…//»

Диаграммы не должны быть понятными только после изучения «языка диаграмм». Они или сразу понятны, или нет.

Чем проще диаграммы, тем лучше. Вообще идеально смотрятся узлы без рамки, и GraphViz их делает безупречно.

Чем меньше стрелок на диаграмме, тем лучше. Если возникает МНОГО обращений «вперед-назад», если появляется много перекрестных стрелок во все стороны, значит, надо упрощать саму суть рассказываемого. Не надо даже стараться всё-всё-всё выразить на одной картинке.

Чем меньше диаграммы, тем лучше. Если получается монстр, его надо разбить на отдельные маленькие и показывать по-отдельности.

Чем меньше слов на диаграмме, тем больше смысла. Те же слайды, просто в другом виде.
